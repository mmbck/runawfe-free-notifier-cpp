/* soapStub.h
   Generated by gSOAP 2.8.62 for ServerAPI.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://impl.service.wfe.runa.ru/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20862
# error "GSOAP VERSION 20862 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* ServerAPI.h:324 */
#ifndef SOAP_TYPE_ns1__classPresentationType
#define SOAP_TYPE_ns1__classPresentationType (63)
/* ns1:classPresentationType */
enum ns1__classPresentationType {
	ns1__classPresentationType__NONE = 0,
	ns1__classPresentationType__SYSTEM_USCORELOG = 1,
	ns1__classPresentationType__EXECUTOR = 2,
	ns1__classPresentationType__ACTOR = 3,
	ns1__classPresentationType__GROUP = 4,
	ns1__classPresentationType__RELATION = 5,
	ns1__classPresentationType__RELATIONPAIR = 6,
	ns1__classPresentationType__DEFINITION = 7,
	ns1__classPresentationType__DEFINITION_USCOREHISTORY = 8,
	ns1__classPresentationType__PROCESS = 9,
	ns1__classPresentationType__TASK = 10,
	ns1__classPresentationType__TASK_USCOREOBSERVABLE = 11,
	ns1__classPresentationType__REPORTS = 12,
	ns1__classPresentationType__PROCESS_USCOREWITH_USCORETASKS = 13
};
#endif

/* ServerAPI.h:352 */
#ifndef SOAP_TYPE_ns1__variableStoreType
#define SOAP_TYPE_ns1__variableStoreType (65)
/* ns1:variableStoreType */
enum ns1__variableStoreType {
	ns1__variableStoreType__DEFAULT = 0,
	ns1__variableStoreType__BLOB = 1
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* ServerAPI.h:139 */
class xsd__base64Binary;	/* ServerAPI.h:142 */
class xsd__base64Binary_;	/* ServerAPI.h:150 */
class xsd__boolean;	/* ServerAPI.h:157 */
class xsd__dateTime;	/* ServerAPI.h:164 */
class xsd__int;	/* ServerAPI.h:171 */
class xsd__long;	/* ServerAPI.h:178 */
class xsd__string;	/* ServerAPI.h:185 */
class ns1__classPresentationType_;	/* ServerAPI.h:343 */
class ns1__variableStoreType_;	/* ServerAPI.h:359 */
class ns1__authenticateByCallerPrincipal;	/* ServerAPI.h:199 */
class ns1__authenticateByCallerPrincipalResponse;	/* ServerAPI.h:202 */
class ns1__user;	/* ServerAPI.h:205 */
class ns1__identifiable;	/* ServerAPI.h:217 */
class ns1__authenticateByLoginPassword;	/* ServerAPI.h:223 */
class ns1__authenticateByLoginPasswordResponse;	/* ServerAPI.h:226 */
class ns1__authenticateByTrustedPrincipal;	/* ServerAPI.h:229 */
class ns1__authenticateByTrustedPrincipalResponse;	/* ServerAPI.h:232 */
class ns1__authenticateByKerberos;	/* ServerAPI.h:235 */
class ns1__authenticateByKerberosResponse;	/* ServerAPI.h:238 */
class ns1__reassignTask;	/* ServerAPI.h:241 */
class ns1__reassignTaskResponse;	/* ServerAPI.h:244 */
class ns1__getMyTasks;	/* ServerAPI.h:247 */
class ns1__batchPresentation;	/* ServerAPI.h:250 */
class ns1__getMyTasksResponse;	/* ServerAPI.h:253 */
class ns1__wfTask;	/* ServerAPI.h:256 */
class ns1__wfVariable;	/* ServerAPI.h:259 */
class ns1__variableDefinition;	/* ServerAPI.h:262 */
class _ns1__userType_attributesMap_entry;	/* ServerAPI.h:828 */
class _ns1__userType_attributesMap;	/* ServerAPI.h:814 */
class ns1__userType;	/* ServerAPI.h:265 */
class ns1__markTaskOpened;	/* ServerAPI.h:268 */
class ns1__markTaskOpenedResponse;	/* ServerAPI.h:271 */
class ns1__assignTask;	/* ServerAPI.h:274 */
class ns1__assignTaskResponse;	/* ServerAPI.h:277 */
class ns1__getTasks;	/* ServerAPI.h:280 */
class ns1__getTasksResponse;	/* ServerAPI.h:283 */
class ns1__completeTaskWS;	/* ServerAPI.h:286 */
class ns1__variable;	/* ServerAPI.h:289 */
class ns1__completeTaskWSResponse;	/* ServerAPI.h:292 */
class ns1__getProcessTasks;	/* ServerAPI.h:295 */
class ns1__getProcessTasksResponse;	/* ServerAPI.h:298 */
class ns1__getTask;	/* ServerAPI.h:301 */
class ns1__getTaskResponse;	/* ServerAPI.h:304 */
class ns1__reassignTasks;	/* ServerAPI.h:307 */
class ns1__reassignTasksResponse;	/* ServerAPI.h:310 */
class ns1__identifiableBase;	/* ServerAPI.h:214 */
class ns1__executor;	/* ServerAPI.h:211 */
class ns1__actor;	/* ServerAPI.h:208 */
class ns1__wfExecutor;	/* ServerAPI.h:220 */
struct __ns1__authenticateByCallerPrincipal;	/* ServerAPI.h:1509 */
struct __ns1__authenticateByLoginPassword;	/* ServerAPI.h:1577 */
struct __ns1__authenticateByTrustedPrincipal;	/* ServerAPI.h:1645 */
struct __ns1__authenticateByKerberos;	/* ServerAPI.h:1713 */
struct __ns1__reassignTask;	/* ServerAPI.h:1781 */
struct __ns1__getMyTasks;	/* ServerAPI.h:1849 */
struct __ns1__markTaskOpenedResponse;	/* ServerAPI.h:1917 */
struct __ns1__markTaskOpened;	/* ServerAPI.h:1917 */
struct __ns1__assignTaskResponse;	/* ServerAPI.h:1985 */
struct __ns1__assignTask;	/* ServerAPI.h:1985 */
struct __ns1__getTasks;	/* ServerAPI.h:2053 */
struct __ns1__completeTaskWSResponse;	/* ServerAPI.h:2121 */
struct __ns1__completeTaskWS;	/* ServerAPI.h:2121 */
struct __ns1__getProcessTasks;	/* ServerAPI.h:2189 */
struct __ns1__getTask;	/* ServerAPI.h:2257 */
struct __ns1__reassignTasks;	/* ServerAPI.h:2325 */

/* ServerAPI.h:139 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:142 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (10)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:150 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (14)
/* Type xsd__base64Binary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
        virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary_); }
      public:
        /// Constructor with initializations
        xsd__base64Binary_() : __item() { }
        virtual ~xsd__base64Binary_() { }
        /// Friend allocator used by soap_new_xsd__base64Binary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:157 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (15)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean() : __item() { }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:164 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (17)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime() : __item() { }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:171 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (19)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int() : __item() { }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:178 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (20)
/* Type xsd__long is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:long': */
class SOAP_CMAC xsd__long : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__long; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long, default initialized and not managed by a soap context
        virtual xsd__long *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__long); }
      public:
        /// Constructor with initializations
        xsd__long() : __item() { }
        virtual ~xsd__long() { }
        /// Friend allocator used by soap_new_xsd__long(struct soap*, int)
        friend SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:185 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (22)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        wchar_t *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string() : __item() { }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:343 */
#ifndef SOAP_TYPE_ns1__classPresentationType_
#define SOAP_TYPE_ns1__classPresentationType_ (64)
/* Type ns1__classPresentationType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:classPresentationType': */
class SOAP_CMAC ns1__classPresentationType_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns1:classPresentationType' wrapped by this struct
        enum ns1__classPresentationType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns1__classPresentationType_
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__classPresentationType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__classPresentationType_, default initialized and not managed by a soap context
        virtual ns1__classPresentationType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__classPresentationType_); }
      public:
        /// Constructor with initializations
        ns1__classPresentationType_() : __item() { }
        virtual ~ns1__classPresentationType_() { }
        /// Friend allocator used by soap_new_ns1__classPresentationType_(struct soap*, int)
        friend SOAP_FMAC1 ns1__classPresentationType_ * SOAP_FMAC2 soap_instantiate_ns1__classPresentationType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:359 */
#ifndef SOAP_TYPE_ns1__variableStoreType_
#define SOAP_TYPE_ns1__variableStoreType_ (66)
/* Type ns1__variableStoreType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:variableStoreType': */
class SOAP_CMAC ns1__variableStoreType_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns1:variableStoreType' wrapped by this struct
        enum ns1__variableStoreType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns1__variableStoreType_
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__variableStoreType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__variableStoreType_, default initialized and not managed by a soap context
        virtual ns1__variableStoreType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__variableStoreType_); }
      public:
        /// Constructor with initializations
        ns1__variableStoreType_() : __item() { }
        virtual ~ns1__variableStoreType_() { }
        /// Friend allocator used by soap_new_ns1__variableStoreType_(struct soap*, int)
        friend SOAP_FMAC1 ns1__variableStoreType_ * SOAP_FMAC2 soap_instantiate_ns1__variableStoreType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:199 */
#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipal
#define SOAP_TYPE_ns1__authenticateByCallerPrincipal (25)
/* Type ns1__authenticateByCallerPrincipal is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:authenticateByCallerPrincipal': */
class SOAP_CMAC ns1__authenticateByCallerPrincipal : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByCallerPrincipal
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByCallerPrincipal; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByCallerPrincipal, default initialized and not managed by a soap context
        virtual ns1__authenticateByCallerPrincipal *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByCallerPrincipal); }
      public:
        /// Constructor with initializations
        ns1__authenticateByCallerPrincipal() { }
        virtual ~ns1__authenticateByCallerPrincipal() { }
        /// Friend allocator used by soap_new_ns1__authenticateByCallerPrincipal(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByCallerPrincipal * SOAP_FMAC2 soap_instantiate_ns1__authenticateByCallerPrincipal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:202 */
#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse
#define SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse (26)
/* Type ns1__authenticateByCallerPrincipalResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:authenticateByCallerPrincipalResponse': */
class SOAP_CMAC ns1__authenticateByCallerPrincipalResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:user'
        ns1__user *result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByCallerPrincipalResponse, default initialized and not managed by a soap context
        virtual ns1__authenticateByCallerPrincipalResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByCallerPrincipalResponse); }
      public:
        /// Constructor with initializations
        ns1__authenticateByCallerPrincipalResponse() : result() { }
        virtual ~ns1__authenticateByCallerPrincipalResponse() { }
        /// Friend allocator used by soap_new_ns1__authenticateByCallerPrincipalResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByCallerPrincipalResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByCallerPrincipalResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:205 */
#ifndef SOAP_TYPE_ns1__user
#define SOAP_TYPE_ns1__user (27)
/* Type ns1__user is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:user': */
class SOAP_CMAC ns1__user : public xsd__anyType {
      public:
        /// Optional element 'actor' of XSD type 'ns1:actor'
        ns1__actor *actor;
        /// Optional element 'securedKey' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *securedKey;
      public:
        /// Return unique type id SOAP_TYPE_ns1__user
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__user; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__user, default initialized and not managed by a soap context
        virtual ns1__user *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__user); }
      public:
        /// Constructor with initializations
        ns1__user() : actor(), securedKey() { }
        virtual ~ns1__user() { }
        /// Friend allocator used by soap_new_ns1__user(struct soap*, int)
        friend SOAP_FMAC1 ns1__user * SOAP_FMAC2 soap_instantiate_ns1__user(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:217 */
#ifndef SOAP_TYPE_ns1__identifiable
#define SOAP_TYPE_ns1__identifiable (31)
/* Type ns1__identifiable is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:identifiable': */
class SOAP_CMAC ns1__identifiable : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__identifiable
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__identifiable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__identifiable, default initialized and not managed by a soap context
        virtual ns1__identifiable *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__identifiable); }
      public:
        /// Constructor with initializations
        ns1__identifiable() { }
        virtual ~ns1__identifiable() { }
        /// Friend allocator used by soap_new_ns1__identifiable(struct soap*, int)
        friend SOAP_FMAC1 ns1__identifiable * SOAP_FMAC2 soap_instantiate_ns1__identifiable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:223 */
#ifndef SOAP_TYPE_ns1__authenticateByLoginPassword
#define SOAP_TYPE_ns1__authenticateByLoginPassword (33)
/* Type ns1__authenticateByLoginPassword is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:authenticateByLoginPassword': */
class SOAP_CMAC ns1__authenticateByLoginPassword : public xsd__anyType {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        wchar_t *name;
        /// Optional element 'password' of XSD type 'xsd:string'
        wchar_t *password;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByLoginPassword
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByLoginPassword; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByLoginPassword, default initialized and not managed by a soap context
        virtual ns1__authenticateByLoginPassword *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByLoginPassword); }
      public:
        /// Constructor with initializations
        ns1__authenticateByLoginPassword() : name(), password() { }
        virtual ~ns1__authenticateByLoginPassword() { }
        /// Friend allocator used by soap_new_ns1__authenticateByLoginPassword(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByLoginPassword * SOAP_FMAC2 soap_instantiate_ns1__authenticateByLoginPassword(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:226 */
#ifndef SOAP_TYPE_ns1__authenticateByLoginPasswordResponse
#define SOAP_TYPE_ns1__authenticateByLoginPasswordResponse (34)
/* Type ns1__authenticateByLoginPasswordResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:authenticateByLoginPasswordResponse': */
class SOAP_CMAC ns1__authenticateByLoginPasswordResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:user'
        ns1__user *result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByLoginPasswordResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByLoginPasswordResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByLoginPasswordResponse, default initialized and not managed by a soap context
        virtual ns1__authenticateByLoginPasswordResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByLoginPasswordResponse); }
      public:
        /// Constructor with initializations
        ns1__authenticateByLoginPasswordResponse() : result() { }
        virtual ~ns1__authenticateByLoginPasswordResponse() { }
        /// Friend allocator used by soap_new_ns1__authenticateByLoginPasswordResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByLoginPasswordResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByLoginPasswordResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:229 */
#ifndef SOAP_TYPE_ns1__authenticateByTrustedPrincipal
#define SOAP_TYPE_ns1__authenticateByTrustedPrincipal (35)
/* Type ns1__authenticateByTrustedPrincipal is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:authenticateByTrustedPrincipal': */
class SOAP_CMAC ns1__authenticateByTrustedPrincipal : public xsd__anyType {
      public:
        /// Optional element 'serviceUser' of XSD type 'ns1:user'
        ns1__user *serviceUser;
        /// Optional element 'login' of XSD type 'xsd:string'
        wchar_t *login;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByTrustedPrincipal
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByTrustedPrincipal; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByTrustedPrincipal, default initialized and not managed by a soap context
        virtual ns1__authenticateByTrustedPrincipal *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByTrustedPrincipal); }
      public:
        /// Constructor with initializations
        ns1__authenticateByTrustedPrincipal() : serviceUser(), login() { }
        virtual ~ns1__authenticateByTrustedPrincipal() { }
        /// Friend allocator used by soap_new_ns1__authenticateByTrustedPrincipal(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByTrustedPrincipal * SOAP_FMAC2 soap_instantiate_ns1__authenticateByTrustedPrincipal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:232 */
#ifndef SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse
#define SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse (36)
/* Type ns1__authenticateByTrustedPrincipalResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:authenticateByTrustedPrincipalResponse': */
class SOAP_CMAC ns1__authenticateByTrustedPrincipalResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:user'
        ns1__user *result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByTrustedPrincipalResponse, default initialized and not managed by a soap context
        virtual ns1__authenticateByTrustedPrincipalResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByTrustedPrincipalResponse); }
      public:
        /// Constructor with initializations
        ns1__authenticateByTrustedPrincipalResponse() : result() { }
        virtual ~ns1__authenticateByTrustedPrincipalResponse() { }
        /// Friend allocator used by soap_new_ns1__authenticateByTrustedPrincipalResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByTrustedPrincipalResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByTrustedPrincipalResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:235 */
#ifndef SOAP_TYPE_ns1__authenticateByKerberos
#define SOAP_TYPE_ns1__authenticateByKerberos (37)
/* Type ns1__authenticateByKerberos is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:authenticateByKerberos': */
class SOAP_CMAC ns1__authenticateByKerberos : public xsd__anyType {
      public:
        /// Optional element 'token' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *token;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByKerberos
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByKerberos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByKerberos, default initialized and not managed by a soap context
        virtual ns1__authenticateByKerberos *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByKerberos); }
      public:
        /// Constructor with initializations
        ns1__authenticateByKerberos() : token() { }
        virtual ~ns1__authenticateByKerberos() { }
        /// Friend allocator used by soap_new_ns1__authenticateByKerberos(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByKerberos * SOAP_FMAC2 soap_instantiate_ns1__authenticateByKerberos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:238 */
#ifndef SOAP_TYPE_ns1__authenticateByKerberosResponse
#define SOAP_TYPE_ns1__authenticateByKerberosResponse (38)
/* Type ns1__authenticateByKerberosResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:authenticateByKerberosResponse': */
class SOAP_CMAC ns1__authenticateByKerberosResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:user'
        ns1__user *result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authenticateByKerberosResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authenticateByKerberosResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authenticateByKerberosResponse, default initialized and not managed by a soap context
        virtual ns1__authenticateByKerberosResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authenticateByKerberosResponse); }
      public:
        /// Constructor with initializations
        ns1__authenticateByKerberosResponse() : result() { }
        virtual ~ns1__authenticateByKerberosResponse() { }
        /// Friend allocator used by soap_new_ns1__authenticateByKerberosResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__authenticateByKerberosResponse * SOAP_FMAC2 soap_instantiate_ns1__authenticateByKerberosResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:241 */
#ifndef SOAP_TYPE_ns1__reassignTask
#define SOAP_TYPE_ns1__reassignTask (39)
/* Type ns1__reassignTask is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:reassignTask': */
class SOAP_CMAC ns1__reassignTask : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'batchPresentation' of XSD type 'xsd:long'
        LONG64 *batchPresentation;
      public:
        /// Return unique type id SOAP_TYPE_ns1__reassignTask
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__reassignTask; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__reassignTask, default initialized and not managed by a soap context
        virtual ns1__reassignTask *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__reassignTask); }
      public:
        /// Constructor with initializations
        ns1__reassignTask() : user(), batchPresentation() { }
        virtual ~ns1__reassignTask() { }
        /// Friend allocator used by soap_new_ns1__reassignTask(struct soap*, int)
        friend SOAP_FMAC1 ns1__reassignTask * SOAP_FMAC2 soap_instantiate_ns1__reassignTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:244 */
#ifndef SOAP_TYPE_ns1__reassignTaskResponse
#define SOAP_TYPE_ns1__reassignTaskResponse (40)
/* Type ns1__reassignTaskResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:reassignTaskResponse': */
class SOAP_CMAC ns1__reassignTaskResponse : public xsd__anyType {
      public:
        /// Required element 'result' of XSD type 'xsd:boolean'
        bool result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__reassignTaskResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__reassignTaskResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__reassignTaskResponse, default initialized and not managed by a soap context
        virtual ns1__reassignTaskResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__reassignTaskResponse); }
      public:
        /// Constructor with initializations
        ns1__reassignTaskResponse() : result() { }
        virtual ~ns1__reassignTaskResponse() { }
        /// Friend allocator used by soap_new_ns1__reassignTaskResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__reassignTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__reassignTaskResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:247 */
#ifndef SOAP_TYPE_ns1__getMyTasks
#define SOAP_TYPE_ns1__getMyTasks (41)
/* Type ns1__getMyTasks is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getMyTasks': */
class SOAP_CMAC ns1__getMyTasks : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'batchPresentation' of XSD type 'ns1:batchPresentation'
        ns1__batchPresentation *batchPresentation;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getMyTasks
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getMyTasks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getMyTasks, default initialized and not managed by a soap context
        virtual ns1__getMyTasks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getMyTasks); }
      public:
        /// Constructor with initializations
        ns1__getMyTasks() : user(), batchPresentation() { }
        virtual ~ns1__getMyTasks() { }
        /// Friend allocator used by soap_new_ns1__getMyTasks(struct soap*, int)
        friend SOAP_FMAC1 ns1__getMyTasks * SOAP_FMAC2 soap_instantiate_ns1__getMyTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:250 */
#ifndef SOAP_TYPE_ns1__batchPresentation
#define SOAP_TYPE_ns1__batchPresentation (42)
/* Type ns1__batchPresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:batchPresentation': */
class SOAP_CMAC ns1__batchPresentation : public xsd__anyType {
      public:
        /// Optional element 'id' of XSD type 'xsd:long'
        LONG64 *id;
        /// Optional element 'version' of XSD type 'xsd:long'
        LONG64 *version;
        /// Optional element 'type' of XSD type 'ns1:classPresentationType'
        enum ns1__classPresentationType *type;
        /// Optional element 'category' of XSD type 'xsd:string'
        wchar_t *category;
        /// Optional element 'name' of XSD type 'xsd:string'
        wchar_t *name;
        /// Required element 'active' of XSD type 'xsd:boolean'
        bool active;
        /// Required element 'rangeSize' of XSD type 'xsd:int'
        int rangeSize;
        /// Required element 'pageNumber' of XSD type 'xsd:int'
        int pageNumber;
        /// Optional element 'fieldsData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *fieldsData;
        /// Optional element 'createDate' of XSD type 'xsd:dateTime'
        time_t *createDate;
        /// Required element 'shared' of XSD type 'xsd:boolean'
        bool shared;
      public:
        /// Return unique type id SOAP_TYPE_ns1__batchPresentation
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__batchPresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__batchPresentation, default initialized and not managed by a soap context
        virtual ns1__batchPresentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__batchPresentation); }
      public:
        /// Constructor with initializations
        ns1__batchPresentation() : id(), version(), type(), category(), name(), active(), rangeSize(), pageNumber(), fieldsData(), createDate(), shared() { }
        virtual ~ns1__batchPresentation() { }
        /// Friend allocator used by soap_new_ns1__batchPresentation(struct soap*, int)
        friend SOAP_FMAC1 ns1__batchPresentation * SOAP_FMAC2 soap_instantiate_ns1__batchPresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:253 */
#ifndef SOAP_TYPE_ns1__getMyTasksResponse
#define SOAP_TYPE_ns1__getMyTasksResponse (43)
/* Type ns1__getMyTasksResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getMyTasksResponse': */
class SOAP_CMAC ns1__getMyTasksResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:wfTask'
        std::vector<ns1__wfTask *> result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getMyTasksResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getMyTasksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getMyTasksResponse, default initialized and not managed by a soap context
        virtual ns1__getMyTasksResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getMyTasksResponse); }
      public:
        /// Constructor with initializations
        ns1__getMyTasksResponse() : result() { }
        virtual ~ns1__getMyTasksResponse() { }
        /// Friend allocator used by soap_new_ns1__getMyTasksResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getMyTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getMyTasksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:256 */
#ifndef SOAP_TYPE_ns1__wfTask
#define SOAP_TYPE_ns1__wfTask (44)
/* Type ns1__wfTask is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:wfTask': */
class SOAP_CMAC ns1__wfTask : public xsd__anyType {
      public:
        /// Optional element 'id' of XSD type 'xsd:long'
        LONG64 *id;
        /// Optional element 'name' of XSD type 'xsd:string'
        wchar_t *name;
        /// Optional element 'nodeId' of XSD type 'xsd:string'
        wchar_t *nodeId;
        /// Optional element 'description' of XSD type 'xsd:string'
        wchar_t *description;
        /// Optional element 'swimlaneName' of XSD type 'xsd:string'
        wchar_t *swimlaneName;
        /// Optional element 'owner' of XSD type 'ns1:wfExecutor'
        ns1__wfExecutor *owner;
        /// Optional element 'targetActor' of XSD type 'ns1:actor'
        ns1__actor *targetActor;
        /// Optional element 'definitionId' of XSD type 'xsd:long'
        LONG64 *definitionId;
        /// Optional element 'definitionName' of XSD type 'xsd:string'
        wchar_t *definitionName;
        /// Optional element 'processId' of XSD type 'xsd:long'
        LONG64 *processId;
        /// Optional element 'processHierarchyIds' of XSD type 'xsd:string'
        wchar_t *processHierarchyIds;
        /// Optional element 'tokenId' of XSD type 'xsd:long'
        LONG64 *tokenId;
        /// Optional element 'creationDate' of XSD type 'xsd:dateTime'
        time_t *creationDate;
        /// Optional element 'deadlineDate' of XSD type 'xsd:dateTime'
        time_t *deadlineDate;
        /// Optional element 'deadlineWarningDate' of XSD type 'xsd:dateTime'
        time_t *deadlineWarningDate;
        /// Optional element 'assignDate' of XSD type 'xsd:dateTime'
        time_t *assignDate;
        /// Required element 'escalated' of XSD type 'xsd:boolean'
        bool escalated;
        /// Required element 'firstOpen' of XSD type 'xsd:boolean'
        bool firstOpen;
        /// Required element 'acquiredBySubstitution' of XSD type 'xsd:boolean'
        bool acquiredBySubstitution;
        /// Optional element 'multitaskIndex' of XSD type 'xsd:int'
        int *multitaskIndex;
        /// Required element 'readOnly' of XSD type 'xsd:boolean'
        bool readOnly;
        /// Optional element 'variables' of XSD type 'ns1:wfVariable'
        std::vector<ns1__wfVariable *> variables;
      public:
        /// Return unique type id SOAP_TYPE_ns1__wfTask
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__wfTask; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__wfTask, default initialized and not managed by a soap context
        virtual ns1__wfTask *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__wfTask); }
      public:
        /// Constructor with initializations
        ns1__wfTask() : id(), name(), nodeId(), description(), swimlaneName(), owner(), targetActor(), definitionId(), definitionName(), processId(), processHierarchyIds(), tokenId(), creationDate(), deadlineDate(), deadlineWarningDate(), assignDate(), escalated(), firstOpen(), acquiredBySubstitution(), multitaskIndex(), readOnly(), variables() { }
        virtual ~ns1__wfTask() { }
        /// Friend allocator used by soap_new_ns1__wfTask(struct soap*, int)
        friend SOAP_FMAC1 ns1__wfTask * SOAP_FMAC2 soap_instantiate_ns1__wfTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:259 */
#ifndef SOAP_TYPE_ns1__wfVariable
#define SOAP_TYPE_ns1__wfVariable (45)
/* Type ns1__wfVariable is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:wfVariable': */
class SOAP_CMAC ns1__wfVariable : public xsd__anyType {
      public:
        /// Optional element 'definition' of XSD type 'ns1:variableDefinition'
        ns1__variableDefinition *definition;
        /// Optional element 'value' of XSD type 'xsd:anyType'
        xsd__anyType *value;
      public:
        /// Return unique type id SOAP_TYPE_ns1__wfVariable
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__wfVariable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__wfVariable, default initialized and not managed by a soap context
        virtual ns1__wfVariable *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__wfVariable); }
      public:
        /// Constructor with initializations
        ns1__wfVariable() : definition(), value() { }
        virtual ~ns1__wfVariable() { }
        /// Friend allocator used by soap_new_ns1__wfVariable(struct soap*, int)
        friend SOAP_FMAC1 ns1__wfVariable * SOAP_FMAC2 soap_instantiate_ns1__wfVariable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:262 */
#ifndef SOAP_TYPE_ns1__variableDefinition
#define SOAP_TYPE_ns1__variableDefinition (46)
/* Type ns1__variableDefinition is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:variableDefinition': */
class SOAP_CMAC ns1__variableDefinition : public xsd__anyType {
      public:
        /// Required element 'synthetic' of XSD type 'xsd:boolean'
        bool synthetic;
        /// Optional element 'name' of XSD type 'xsd:string'
        wchar_t *name;
        /// Optional element 'scriptingName' of XSD type 'xsd:string'
        wchar_t *scriptingName;
        /// Optional element 'description' of XSD type 'xsd:string'
        wchar_t *description;
        /// Optional element 'format' of XSD type 'xsd:string'
        wchar_t *format;
        /// Optional element 'formatLabel' of XSD type 'xsd:string'
        wchar_t *formatLabel;
        /// Optional element 'userType' of XSD type 'ns1:userType'
        ns1__userType *userType;
        /// Optional element 'formatComponentUserTypes' of XSD type 'ns1:userType'
        std::vector<ns1__userType *> formatComponentUserTypes;
        /// Required element 'publicAccess' of XSD type 'xsd:boolean'
        bool publicAccess;
        /// Optional element 'defaultValue' of XSD type 'xsd:anyType'
        xsd__anyType *defaultValue;
        /// Optional element 'storeType' of XSD type 'ns1:variableStoreType'
        enum ns1__variableStoreType *storeType;
      public:
        /// Return unique type id SOAP_TYPE_ns1__variableDefinition
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__variableDefinition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__variableDefinition, default initialized and not managed by a soap context
        virtual ns1__variableDefinition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__variableDefinition); }
      public:
        /// Constructor with initializations
        ns1__variableDefinition() : synthetic(), name(), scriptingName(), description(), format(), formatLabel(), userType(), formatComponentUserTypes(), publicAccess(), defaultValue(), storeType() { }
        virtual ~ns1__variableDefinition() { }
        /// Friend allocator used by soap_new_ns1__variableDefinition(struct soap*, int)
        friend SOAP_FMAC1 ns1__variableDefinition * SOAP_FMAC2 soap_instantiate_ns1__variableDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:828 */
#ifndef SOAP_TYPE__ns1__userType_attributesMap_entry
#define SOAP_TYPE__ns1__userType_attributesMap_entry (87)
/* Type _ns1__userType_attributesMap_entry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:userType-attributesMap-entry': */
class SOAP_CMAC _ns1__userType_attributesMap_entry {
      public:
        /// Optional element 'key' of XSD type 'xsd:string'
        wchar_t *key;
        /// Optional element 'value' of XSD type 'ns1:variableDefinition'
        ns1__variableDefinition *value;
      public:
        /// Return unique type id SOAP_TYPE__ns1__userType_attributesMap_entry
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__userType_attributesMap_entry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__userType_attributesMap_entry, default initialized and not managed by a soap context
        virtual _ns1__userType_attributesMap_entry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__userType_attributesMap_entry); }
      public:
        /// Constructor with initializations
        _ns1__userType_attributesMap_entry() : key(), value() { }
        virtual ~_ns1__userType_attributesMap_entry() { }
        /// Friend allocator used by soap_new__ns1__userType_attributesMap_entry(struct soap*, int)
        friend SOAP_FMAC1 _ns1__userType_attributesMap_entry * SOAP_FMAC2 soap_instantiate__ns1__userType_attributesMap_entry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:814 */
#ifndef SOAP_TYPE__ns1__userType_attributesMap
#define SOAP_TYPE__ns1__userType_attributesMap (86)
/* complex XSD type 'ns1:userType-attributesMap': */
class SOAP_CMAC _ns1__userType_attributesMap {
      public:
        /// Optional element 'entry' of XSD type 'ns1:userType-attributesMap-entry'
        std::vector<_ns1__userType_attributesMap_entry> entry;
      public:
        /// Return unique type id SOAP_TYPE__ns1__userType_attributesMap
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__userType_attributesMap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__userType_attributesMap, default initialized and not managed by a soap context
        virtual _ns1__userType_attributesMap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__userType_attributesMap); }
      public:
        /// Constructor with initializations
        _ns1__userType_attributesMap() : entry() { }
        virtual ~_ns1__userType_attributesMap() { }
        /// Friend allocator used by soap_new__ns1__userType_attributesMap(struct soap*, int)
        friend SOAP_FMAC1 _ns1__userType_attributesMap * SOAP_FMAC2 soap_instantiate__ns1__userType_attributesMap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:265 */
#ifndef SOAP_TYPE_ns1__userType
#define SOAP_TYPE_ns1__userType (47)
/* Type ns1__userType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:userType': */
class SOAP_CMAC ns1__userType : public xsd__anyType {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        wchar_t *name;
        /// Optional element 'attributes' of XSD type 'ns1:variableDefinition'
        std::vector<ns1__variableDefinition *> attributes;
        /// Required element 'attributesMap' of XSD type 'ns1:userType-attributesMap'
        _ns1__userType_attributesMap attributesMap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__userType
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__userType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__userType, default initialized and not managed by a soap context
        virtual ns1__userType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__userType); }
      public:
        /// Constructor with initializations
        ns1__userType() : name(), attributes(), attributesMap() { }
        virtual ~ns1__userType() { }
        /// Friend allocator used by soap_new_ns1__userType(struct soap*, int)
        friend SOAP_FMAC1 ns1__userType * SOAP_FMAC2 soap_instantiate_ns1__userType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:268 */
#ifndef SOAP_TYPE_ns1__markTaskOpened
#define SOAP_TYPE_ns1__markTaskOpened (48)
/* Type ns1__markTaskOpened is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:markTaskOpened': */
class SOAP_CMAC ns1__markTaskOpened : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'taskId' of XSD type 'xsd:long'
        LONG64 *taskId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__markTaskOpened
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__markTaskOpened; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__markTaskOpened, default initialized and not managed by a soap context
        virtual ns1__markTaskOpened *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__markTaskOpened); }
      public:
        /// Constructor with initializations
        ns1__markTaskOpened() : user(), taskId() { }
        virtual ~ns1__markTaskOpened() { }
        /// Friend allocator used by soap_new_ns1__markTaskOpened(struct soap*, int)
        friend SOAP_FMAC1 ns1__markTaskOpened * SOAP_FMAC2 soap_instantiate_ns1__markTaskOpened(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:271 */
#ifndef SOAP_TYPE_ns1__markTaskOpenedResponse
#define SOAP_TYPE_ns1__markTaskOpenedResponse (49)
/* Type ns1__markTaskOpenedResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:markTaskOpenedResponse': */
class SOAP_CMAC ns1__markTaskOpenedResponse : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__markTaskOpenedResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__markTaskOpenedResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__markTaskOpenedResponse, default initialized and not managed by a soap context
        virtual ns1__markTaskOpenedResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__markTaskOpenedResponse); }
      public:
        /// Constructor with initializations
        ns1__markTaskOpenedResponse() { }
        virtual ~ns1__markTaskOpenedResponse() { }
        /// Friend allocator used by soap_new_ns1__markTaskOpenedResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__markTaskOpenedResponse * SOAP_FMAC2 soap_instantiate_ns1__markTaskOpenedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:274 */
#ifndef SOAP_TYPE_ns1__assignTask
#define SOAP_TYPE_ns1__assignTask (50)
/* Type ns1__assignTask is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:assignTask': */
class SOAP_CMAC ns1__assignTask : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'taskId' of XSD type 'xsd:long'
        LONG64 *taskId;
        /// Optional element 'previousOwner' of XSD type 'ns1:wfExecutor'
        ns1__wfExecutor *previousOwner;
        /// Optional element 'newExecutor' of XSD type 'ns1:wfExecutor'
        ns1__wfExecutor *newExecutor;
      public:
        /// Return unique type id SOAP_TYPE_ns1__assignTask
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__assignTask; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__assignTask, default initialized and not managed by a soap context
        virtual ns1__assignTask *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__assignTask); }
      public:
        /// Constructor with initializations
        ns1__assignTask() : user(), taskId(), previousOwner(), newExecutor() { }
        virtual ~ns1__assignTask() { }
        /// Friend allocator used by soap_new_ns1__assignTask(struct soap*, int)
        friend SOAP_FMAC1 ns1__assignTask * SOAP_FMAC2 soap_instantiate_ns1__assignTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:277 */
#ifndef SOAP_TYPE_ns1__assignTaskResponse
#define SOAP_TYPE_ns1__assignTaskResponse (51)
/* Type ns1__assignTaskResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:assignTaskResponse': */
class SOAP_CMAC ns1__assignTaskResponse : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__assignTaskResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__assignTaskResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__assignTaskResponse, default initialized and not managed by a soap context
        virtual ns1__assignTaskResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__assignTaskResponse); }
      public:
        /// Constructor with initializations
        ns1__assignTaskResponse() { }
        virtual ~ns1__assignTaskResponse() { }
        /// Friend allocator used by soap_new_ns1__assignTaskResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__assignTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__assignTaskResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:280 */
#ifndef SOAP_TYPE_ns1__getTasks
#define SOAP_TYPE_ns1__getTasks (52)
/* Type ns1__getTasks is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getTasks': */
class SOAP_CMAC ns1__getTasks : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'batchPresentation' of XSD type 'ns1:batchPresentation'
        ns1__batchPresentation *batchPresentation;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getTasks
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getTasks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getTasks, default initialized and not managed by a soap context
        virtual ns1__getTasks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getTasks); }
      public:
        /// Constructor with initializations
        ns1__getTasks() : user(), batchPresentation() { }
        virtual ~ns1__getTasks() { }
        /// Friend allocator used by soap_new_ns1__getTasks(struct soap*, int)
        friend SOAP_FMAC1 ns1__getTasks * SOAP_FMAC2 soap_instantiate_ns1__getTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:283 */
#ifndef SOAP_TYPE_ns1__getTasksResponse
#define SOAP_TYPE_ns1__getTasksResponse (53)
/* Type ns1__getTasksResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getTasksResponse': */
class SOAP_CMAC ns1__getTasksResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:wfTask'
        std::vector<ns1__wfTask *> result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getTasksResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getTasksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getTasksResponse, default initialized and not managed by a soap context
        virtual ns1__getTasksResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getTasksResponse); }
      public:
        /// Constructor with initializations
        ns1__getTasksResponse() : result() { }
        virtual ~ns1__getTasksResponse() { }
        /// Friend allocator used by soap_new_ns1__getTasksResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getTasksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:286 */
#ifndef SOAP_TYPE_ns1__completeTaskWS
#define SOAP_TYPE_ns1__completeTaskWS (54)
/* Type ns1__completeTaskWS is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:completeTaskWS': */
class SOAP_CMAC ns1__completeTaskWS : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'taskId' of XSD type 'xsd:long'
        LONG64 *taskId;
        /// Optional element 'variables' of XSD type 'ns1:variable'
        std::vector<ns1__variable *> variables;
        /// Optional element 'swimlaneActorId' of XSD type 'xsd:long'
        LONG64 *swimlaneActorId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__completeTaskWS
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__completeTaskWS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__completeTaskWS, default initialized and not managed by a soap context
        virtual ns1__completeTaskWS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__completeTaskWS); }
      public:
        /// Constructor with initializations
        ns1__completeTaskWS() : user(), taskId(), variables(), swimlaneActorId() { }
        virtual ~ns1__completeTaskWS() { }
        /// Friend allocator used by soap_new_ns1__completeTaskWS(struct soap*, int)
        friend SOAP_FMAC1 ns1__completeTaskWS * SOAP_FMAC2 soap_instantiate_ns1__completeTaskWS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:289 */
#ifndef SOAP_TYPE_ns1__variable
#define SOAP_TYPE_ns1__variable (55)
/* Type ns1__variable is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:variable': */
class SOAP_CMAC ns1__variable : public xsd__anyType {
      public:
        /// Optional element 'name' of XSD type 'xsd:string'
        wchar_t *name;
        /// Optional element 'scriptingName' of XSD type 'xsd:string'
        wchar_t *scriptingName;
        /// Optional element 'format' of XSD type 'xsd:string'
        wchar_t *format;
        /// Optional element 'value' of XSD type 'xsd:string'
        wchar_t *value;
      public:
        /// Return unique type id SOAP_TYPE_ns1__variable
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__variable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__variable, default initialized and not managed by a soap context
        virtual ns1__variable *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__variable); }
      public:
        /// Constructor with initializations
        ns1__variable() : name(), scriptingName(), format(), value() { }
        virtual ~ns1__variable() { }
        /// Friend allocator used by soap_new_ns1__variable(struct soap*, int)
        friend SOAP_FMAC1 ns1__variable * SOAP_FMAC2 soap_instantiate_ns1__variable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:292 */
#ifndef SOAP_TYPE_ns1__completeTaskWSResponse
#define SOAP_TYPE_ns1__completeTaskWSResponse (56)
/* Type ns1__completeTaskWSResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:completeTaskWSResponse': */
class SOAP_CMAC ns1__completeTaskWSResponse : public xsd__anyType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__completeTaskWSResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__completeTaskWSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__completeTaskWSResponse, default initialized and not managed by a soap context
        virtual ns1__completeTaskWSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__completeTaskWSResponse); }
      public:
        /// Constructor with initializations
        ns1__completeTaskWSResponse() { }
        virtual ~ns1__completeTaskWSResponse() { }
        /// Friend allocator used by soap_new_ns1__completeTaskWSResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__completeTaskWSResponse * SOAP_FMAC2 soap_instantiate_ns1__completeTaskWSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:295 */
#ifndef SOAP_TYPE_ns1__getProcessTasks
#define SOAP_TYPE_ns1__getProcessTasks (57)
/* Type ns1__getProcessTasks is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getProcessTasks': */
class SOAP_CMAC ns1__getProcessTasks : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'processId' of XSD type 'xsd:long'
        LONG64 *processId;
        /// Required element 'includeSubprocesses' of XSD type 'xsd:boolean'
        bool includeSubprocesses;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getProcessTasks
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getProcessTasks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getProcessTasks, default initialized and not managed by a soap context
        virtual ns1__getProcessTasks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getProcessTasks); }
      public:
        /// Constructor with initializations
        ns1__getProcessTasks() : user(), processId(), includeSubprocesses() { }
        virtual ~ns1__getProcessTasks() { }
        /// Friend allocator used by soap_new_ns1__getProcessTasks(struct soap*, int)
        friend SOAP_FMAC1 ns1__getProcessTasks * SOAP_FMAC2 soap_instantiate_ns1__getProcessTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:298 */
#ifndef SOAP_TYPE_ns1__getProcessTasksResponse
#define SOAP_TYPE_ns1__getProcessTasksResponse (58)
/* Type ns1__getProcessTasksResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getProcessTasksResponse': */
class SOAP_CMAC ns1__getProcessTasksResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:wfTask'
        std::vector<ns1__wfTask *> result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getProcessTasksResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getProcessTasksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getProcessTasksResponse, default initialized and not managed by a soap context
        virtual ns1__getProcessTasksResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getProcessTasksResponse); }
      public:
        /// Constructor with initializations
        ns1__getProcessTasksResponse() : result() { }
        virtual ~ns1__getProcessTasksResponse() { }
        /// Friend allocator used by soap_new_ns1__getProcessTasksResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getProcessTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__getProcessTasksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:301 */
#ifndef SOAP_TYPE_ns1__getTask
#define SOAP_TYPE_ns1__getTask (59)
/* Type ns1__getTask is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getTask': */
class SOAP_CMAC ns1__getTask : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'taskId' of XSD type 'xsd:long'
        LONG64 *taskId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getTask
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getTask; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getTask, default initialized and not managed by a soap context
        virtual ns1__getTask *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getTask); }
      public:
        /// Constructor with initializations
        ns1__getTask() : user(), taskId() { }
        virtual ~ns1__getTask() { }
        /// Friend allocator used by soap_new_ns1__getTask(struct soap*, int)
        friend SOAP_FMAC1 ns1__getTask * SOAP_FMAC2 soap_instantiate_ns1__getTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:304 */
#ifndef SOAP_TYPE_ns1__getTaskResponse
#define SOAP_TYPE_ns1__getTaskResponse (60)
/* Type ns1__getTaskResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getTaskResponse': */
class SOAP_CMAC ns1__getTaskResponse : public xsd__anyType {
      public:
        /// Optional element 'result' of XSD type 'ns1:wfTask'
        ns1__wfTask *result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getTaskResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getTaskResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getTaskResponse, default initialized and not managed by a soap context
        virtual ns1__getTaskResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getTaskResponse); }
      public:
        /// Constructor with initializations
        ns1__getTaskResponse() : result() { }
        virtual ~ns1__getTaskResponse() { }
        /// Friend allocator used by soap_new_ns1__getTaskResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__getTaskResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:307 */
#ifndef SOAP_TYPE_ns1__reassignTasks
#define SOAP_TYPE_ns1__reassignTasks (61)
/* Type ns1__reassignTasks is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:reassignTasks': */
class SOAP_CMAC ns1__reassignTasks : public xsd__anyType {
      public:
        /// Optional element 'user' of XSD type 'ns1:user'
        ns1__user *user;
        /// Optional element 'batchPresentation' of XSD type 'ns1:batchPresentation'
        ns1__batchPresentation *batchPresentation;
      public:
        /// Return unique type id SOAP_TYPE_ns1__reassignTasks
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__reassignTasks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__reassignTasks, default initialized and not managed by a soap context
        virtual ns1__reassignTasks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__reassignTasks); }
      public:
        /// Constructor with initializations
        ns1__reassignTasks() : user(), batchPresentation() { }
        virtual ~ns1__reassignTasks() { }
        /// Friend allocator used by soap_new_ns1__reassignTasks(struct soap*, int)
        friend SOAP_FMAC1 ns1__reassignTasks * SOAP_FMAC2 soap_instantiate_ns1__reassignTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:310 */
#ifndef SOAP_TYPE_ns1__reassignTasksResponse
#define SOAP_TYPE_ns1__reassignTasksResponse (62)
/* Type ns1__reassignTasksResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:reassignTasksResponse': */
class SOAP_CMAC ns1__reassignTasksResponse : public xsd__anyType {
      public:
        /// Required element 'result' of XSD type 'xsd:int'
        int result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__reassignTasksResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__reassignTasksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__reassignTasksResponse, default initialized and not managed by a soap context
        virtual ns1__reassignTasksResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__reassignTasksResponse); }
      public:
        /// Constructor with initializations
        ns1__reassignTasksResponse() : result() { }
        virtual ~ns1__reassignTasksResponse() { }
        /// Friend allocator used by soap_new_ns1__reassignTasksResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__reassignTasksResponse * SOAP_FMAC2 soap_instantiate_ns1__reassignTasksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:214 */
#ifndef SOAP_TYPE_ns1__identifiableBase
#define SOAP_TYPE_ns1__identifiableBase (30)
/* Type ns1__identifiableBase is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:identifiableBase': */
class SOAP_CMAC ns1__identifiableBase : public ns1__identifiable {
      public:
        /// Return unique type id SOAP_TYPE_ns1__identifiableBase
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__identifiableBase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__identifiableBase, default initialized and not managed by a soap context
        virtual ns1__identifiableBase *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__identifiableBase); }
      public:
        /// Constructor with initializations
        ns1__identifiableBase() { }
        virtual ~ns1__identifiableBase() { }
        /// Friend allocator used by soap_new_ns1__identifiableBase(struct soap*, int)
        friend SOAP_FMAC1 ns1__identifiableBase * SOAP_FMAC2 soap_instantiate_ns1__identifiableBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:211 */
#ifndef SOAP_TYPE_ns1__executor
#define SOAP_TYPE_ns1__executor (29)
/* Type ns1__executor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:executor': */
class SOAP_CMAC ns1__executor : public ns1__identifiableBase {
      public:
        /// Optional element 'id' of XSD type 'xsd:long'
        LONG64 *id;
        /// Optional element 'version' of XSD type 'xsd:long'
        LONG64 *version;
        /// Optional element 'name' of XSD type 'xsd:string'
        wchar_t *name;
        /// Optional element 'description' of XSD type 'xsd:string'
        wchar_t *description;
        /// Optional element 'fullName' of XSD type 'xsd:string'
        wchar_t *fullName;
        /// Optional element 'createDate' of XSD type 'xsd:dateTime'
        time_t *createDate;
      public:
        /// Return unique type id SOAP_TYPE_ns1__executor
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__executor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__executor, default initialized and not managed by a soap context
        virtual ns1__executor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__executor); }
      public:
        /// Constructor with initializations
        ns1__executor() : id(), version(), name(), description(), fullName(), createDate() { }
        virtual ~ns1__executor() { }
        /// Friend allocator used by soap_new_ns1__executor(struct soap*, int)
        friend SOAP_FMAC1 ns1__executor * SOAP_FMAC2 soap_instantiate_ns1__executor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:208 */
#ifndef SOAP_TYPE_ns1__actor
#define SOAP_TYPE_ns1__actor (28)
/* Type ns1__actor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:actor': */
class SOAP_CMAC ns1__actor : public ns1__executor {
      public:
        /// Optional element 'code' of XSD type 'xsd:long'
        LONG64 *code;
        /// Required element 'active' of XSD type 'xsd:boolean'
        bool active;
        /// Optional element 'email' of XSD type 'xsd:string'
        wchar_t *email;
        /// Optional element 'phone' of XSD type 'xsd:string'
        wchar_t *phone;
        /// Optional element 'title' of XSD type 'xsd:string'
        wchar_t *title;
        /// Optional element 'department' of XSD type 'xsd:string'
        wchar_t *department;
      public:
        /// Return unique type id SOAP_TYPE_ns1__actor
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__actor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__actor, default initialized and not managed by a soap context
        virtual ns1__actor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__actor); }
      public:
        /// Constructor with initializations
        ns1__actor() : code(), active(), email(), phone(), title(), department() { }
        virtual ~ns1__actor() { }
        /// Friend allocator used by soap_new_ns1__actor(struct soap*, int)
        friend SOAP_FMAC1 ns1__actor * SOAP_FMAC2 soap_instantiate_ns1__actor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:220 */
#ifndef SOAP_TYPE_ns1__wfExecutor
#define SOAP_TYPE_ns1__wfExecutor (32)
/* Type ns1__wfExecutor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:wfExecutor': */
class SOAP_CMAC ns1__wfExecutor : public ns1__executor {
      public:
        /// Optional element 'executorClassName' of XSD type 'xsd:string'
        wchar_t *executorClassName;
      public:
        /// Return unique type id SOAP_TYPE_ns1__wfExecutor
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__wfExecutor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__wfExecutor, default initialized and not managed by a soap context
        virtual ns1__wfExecutor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__wfExecutor); }
      public:
        /// Constructor with initializations
        ns1__wfExecutor() : executorClassName() { }
        virtual ~ns1__wfExecutor() { }
        /// Friend allocator used by soap_new_ns1__wfExecutor(struct soap*, int)
        friend SOAP_FMAC1 ns1__wfExecutor * SOAP_FMAC2 soap_instantiate_ns1__wfExecutor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1509 */
#ifndef SOAP_TYPE___ns1__authenticateByCallerPrincipal
#define SOAP_TYPE___ns1__authenticateByCallerPrincipal (94)
/* Wrapper: */
struct SOAP_CMAC __ns1__authenticateByCallerPrincipal {
      public:
        /** Optional element 'ns1:authenticateByCallerPrincipal' of XSD type 'ns1:authenticateByCallerPrincipal' */
        ns1__authenticateByCallerPrincipal *ns1__authenticateByCallerPrincipal_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__authenticateByCallerPrincipal */
        long soap_type() const { return SOAP_TYPE___ns1__authenticateByCallerPrincipal; }
        /** Constructor with member initializations */
        __ns1__authenticateByCallerPrincipal() : ns1__authenticateByCallerPrincipal_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__authenticateByCallerPrincipal * SOAP_FMAC2 soap_instantiate___ns1__authenticateByCallerPrincipal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1577 */
#ifndef SOAP_TYPE___ns1__authenticateByLoginPassword
#define SOAP_TYPE___ns1__authenticateByLoginPassword (98)
/* Wrapper: */
struct SOAP_CMAC __ns1__authenticateByLoginPassword {
      public:
        /** Optional element 'ns1:authenticateByLoginPassword' of XSD type 'ns1:authenticateByLoginPassword' */
        ns1__authenticateByLoginPassword *ns1__authenticateByLoginPassword_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__authenticateByLoginPassword */
        long soap_type() const { return SOAP_TYPE___ns1__authenticateByLoginPassword; }
        /** Constructor with member initializations */
        __ns1__authenticateByLoginPassword() : ns1__authenticateByLoginPassword_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__authenticateByLoginPassword * SOAP_FMAC2 soap_instantiate___ns1__authenticateByLoginPassword(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1645 */
#ifndef SOAP_TYPE___ns1__authenticateByTrustedPrincipal
#define SOAP_TYPE___ns1__authenticateByTrustedPrincipal (102)
/* Wrapper: */
struct SOAP_CMAC __ns1__authenticateByTrustedPrincipal {
      public:
        /** Optional element 'ns1:authenticateByTrustedPrincipal' of XSD type 'ns1:authenticateByTrustedPrincipal' */
        ns1__authenticateByTrustedPrincipal *ns1__authenticateByTrustedPrincipal_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__authenticateByTrustedPrincipal */
        long soap_type() const { return SOAP_TYPE___ns1__authenticateByTrustedPrincipal; }
        /** Constructor with member initializations */
        __ns1__authenticateByTrustedPrincipal() : ns1__authenticateByTrustedPrincipal_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__authenticateByTrustedPrincipal * SOAP_FMAC2 soap_instantiate___ns1__authenticateByTrustedPrincipal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1713 */
#ifndef SOAP_TYPE___ns1__authenticateByKerberos
#define SOAP_TYPE___ns1__authenticateByKerberos (106)
/* Wrapper: */
struct SOAP_CMAC __ns1__authenticateByKerberos {
      public:
        /** Optional element 'ns1:authenticateByKerberos' of XSD type 'ns1:authenticateByKerberos' */
        ns1__authenticateByKerberos *ns1__authenticateByKerberos_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__authenticateByKerberos */
        long soap_type() const { return SOAP_TYPE___ns1__authenticateByKerberos; }
        /** Constructor with member initializations */
        __ns1__authenticateByKerberos() : ns1__authenticateByKerberos_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__authenticateByKerberos * SOAP_FMAC2 soap_instantiate___ns1__authenticateByKerberos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1781 */
#ifndef SOAP_TYPE___ns1__reassignTask
#define SOAP_TYPE___ns1__reassignTask (110)
/* Wrapper: */
struct SOAP_CMAC __ns1__reassignTask {
      public:
        /** Optional element 'ns1:reassignTask' of XSD type 'ns1:reassignTask' */
        ns1__reassignTask *ns1__reassignTask_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__reassignTask */
        long soap_type() const { return SOAP_TYPE___ns1__reassignTask; }
        /** Constructor with member initializations */
        __ns1__reassignTask() : ns1__reassignTask_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__reassignTask * SOAP_FMAC2 soap_instantiate___ns1__reassignTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1849 */
#ifndef SOAP_TYPE___ns1__getMyTasks
#define SOAP_TYPE___ns1__getMyTasks (114)
/* Wrapper: */
struct SOAP_CMAC __ns1__getMyTasks {
      public:
        /** Optional element 'ns1:getMyTasks' of XSD type 'ns1:getMyTasks' */
        ns1__getMyTasks *ns1__getMyTasks_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getMyTasks */
        long soap_type() const { return SOAP_TYPE___ns1__getMyTasks; }
        /** Constructor with member initializations */
        __ns1__getMyTasks() : ns1__getMyTasks_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getMyTasks * SOAP_FMAC2 soap_instantiate___ns1__getMyTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1917 */
#ifndef SOAP_TYPE___ns1__markTaskOpenedResponse
#define SOAP_TYPE___ns1__markTaskOpenedResponse (118)
/* Wrapper: */
struct SOAP_CMAC __ns1__markTaskOpenedResponse {
      public:
        /** Required element 'ns1:markTaskOpenedResponse' of XSD type 'ns1:markTaskOpenedResponse' */
        ns1__markTaskOpenedResponse ns1__markTaskOpenedResponse_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__markTaskOpenedResponse */
        long soap_type() const { return SOAP_TYPE___ns1__markTaskOpenedResponse; }
        /** Constructor with member initializations */
        __ns1__markTaskOpenedResponse() : ns1__markTaskOpenedResponse_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__markTaskOpenedResponse * SOAP_FMAC2 soap_instantiate___ns1__markTaskOpenedResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1917 */
#ifndef SOAP_TYPE___ns1__markTaskOpened
#define SOAP_TYPE___ns1__markTaskOpened (119)
/* Wrapper: */
struct SOAP_CMAC __ns1__markTaskOpened {
      public:
        /** Optional element 'ns1:markTaskOpened' of XSD type 'ns1:markTaskOpened' */
        ns1__markTaskOpened *ns1__markTaskOpened_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__markTaskOpened */
        long soap_type() const { return SOAP_TYPE___ns1__markTaskOpened; }
        /** Constructor with member initializations */
        __ns1__markTaskOpened() : ns1__markTaskOpened_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__markTaskOpened * SOAP_FMAC2 soap_instantiate___ns1__markTaskOpened(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1985 */
#ifndef SOAP_TYPE___ns1__assignTaskResponse
#define SOAP_TYPE___ns1__assignTaskResponse (123)
/* Wrapper: */
struct SOAP_CMAC __ns1__assignTaskResponse {
      public:
        /** Required element 'ns1:assignTaskResponse' of XSD type 'ns1:assignTaskResponse' */
        ns1__assignTaskResponse ns1__assignTaskResponse_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__assignTaskResponse */
        long soap_type() const { return SOAP_TYPE___ns1__assignTaskResponse; }
        /** Constructor with member initializations */
        __ns1__assignTaskResponse() : ns1__assignTaskResponse_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__assignTaskResponse * SOAP_FMAC2 soap_instantiate___ns1__assignTaskResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:1985 */
#ifndef SOAP_TYPE___ns1__assignTask
#define SOAP_TYPE___ns1__assignTask (124)
/* Wrapper: */
struct SOAP_CMAC __ns1__assignTask {
      public:
        /** Optional element 'ns1:assignTask' of XSD type 'ns1:assignTask' */
        ns1__assignTask *ns1__assignTask_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__assignTask */
        long soap_type() const { return SOAP_TYPE___ns1__assignTask; }
        /** Constructor with member initializations */
        __ns1__assignTask() : ns1__assignTask_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__assignTask * SOAP_FMAC2 soap_instantiate___ns1__assignTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:2053 */
#ifndef SOAP_TYPE___ns1__getTasks
#define SOAP_TYPE___ns1__getTasks (128)
/* Wrapper: */
struct SOAP_CMAC __ns1__getTasks {
      public:
        /** Optional element 'ns1:getTasks' of XSD type 'ns1:getTasks' */
        ns1__getTasks *ns1__getTasks_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getTasks */
        long soap_type() const { return SOAP_TYPE___ns1__getTasks; }
        /** Constructor with member initializations */
        __ns1__getTasks() : ns1__getTasks_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getTasks * SOAP_FMAC2 soap_instantiate___ns1__getTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:2121 */
#ifndef SOAP_TYPE___ns1__completeTaskWSResponse
#define SOAP_TYPE___ns1__completeTaskWSResponse (132)
/* Wrapper: */
struct SOAP_CMAC __ns1__completeTaskWSResponse {
      public:
        /** Required element 'ns1:completeTaskWSResponse' of XSD type 'ns1:completeTaskWSResponse' */
        ns1__completeTaskWSResponse ns1__completeTaskWSResponse_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__completeTaskWSResponse */
        long soap_type() const { return SOAP_TYPE___ns1__completeTaskWSResponse; }
        /** Constructor with member initializations */
        __ns1__completeTaskWSResponse() : ns1__completeTaskWSResponse_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__completeTaskWSResponse * SOAP_FMAC2 soap_instantiate___ns1__completeTaskWSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:2121 */
#ifndef SOAP_TYPE___ns1__completeTaskWS
#define SOAP_TYPE___ns1__completeTaskWS (133)
/* Wrapper: */
struct SOAP_CMAC __ns1__completeTaskWS {
      public:
        /** Optional element 'ns1:completeTaskWS' of XSD type 'ns1:completeTaskWS' */
        ns1__completeTaskWS *ns1__completeTaskWS_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__completeTaskWS */
        long soap_type() const { return SOAP_TYPE___ns1__completeTaskWS; }
        /** Constructor with member initializations */
        __ns1__completeTaskWS() : ns1__completeTaskWS_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__completeTaskWS * SOAP_FMAC2 soap_instantiate___ns1__completeTaskWS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:2189 */
#ifndef SOAP_TYPE___ns1__getProcessTasks
#define SOAP_TYPE___ns1__getProcessTasks (137)
/* Wrapper: */
struct SOAP_CMAC __ns1__getProcessTasks {
      public:
        /** Optional element 'ns1:getProcessTasks' of XSD type 'ns1:getProcessTasks' */
        ns1__getProcessTasks *ns1__getProcessTasks_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getProcessTasks */
        long soap_type() const { return SOAP_TYPE___ns1__getProcessTasks; }
        /** Constructor with member initializations */
        __ns1__getProcessTasks() : ns1__getProcessTasks_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getProcessTasks * SOAP_FMAC2 soap_instantiate___ns1__getProcessTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:2257 */
#ifndef SOAP_TYPE___ns1__getTask
#define SOAP_TYPE___ns1__getTask (141)
/* Wrapper: */
struct SOAP_CMAC __ns1__getTask {
      public:
        /** Optional element 'ns1:getTask' of XSD type 'ns1:getTask' */
        ns1__getTask *ns1__getTask_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getTask */
        long soap_type() const { return SOAP_TYPE___ns1__getTask; }
        /** Constructor with member initializations */
        __ns1__getTask() : ns1__getTask_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getTask * SOAP_FMAC2 soap_instantiate___ns1__getTask(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:2325 */
#ifndef SOAP_TYPE___ns1__reassignTasks
#define SOAP_TYPE___ns1__reassignTasks (145)
/* Wrapper: */
struct SOAP_CMAC __ns1__reassignTasks {
      public:
        /** Optional element 'ns1:reassignTasks' of XSD type 'ns1:reassignTasks' */
        ns1__reassignTasks *ns1__reassignTasks_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__reassignTasks */
        long soap_type() const { return SOAP_TYPE___ns1__reassignTasks; }
        /** Constructor with member initializations */
        __ns1__reassignTasks() : ns1__reassignTasks_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__reassignTasks * SOAP_FMAC2 soap_instantiate___ns1__reassignTasks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ServerAPI.h:2438 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (146)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ServerAPI.h:2438 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (147)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ServerAPI.h:2438 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (149)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ServerAPI.h:2438 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (152)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* ServerAPI.h:2438 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (153)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (21)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (12)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (11)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (18)
#endif

/* enum ns1__variableStoreType has binding name 'ns1__variableStoreType' for type 'ns1:variableStoreType' */
#ifndef SOAP_TYPE_ns1__variableStoreType
#define SOAP_TYPE_ns1__variableStoreType (65)
#endif

/* enum ns1__classPresentationType has binding name 'ns1__classPresentationType' for type 'ns1:classPresentationType' */
#ifndef SOAP_TYPE_ns1__classPresentationType
#define SOAP_TYPE_ns1__classPresentationType (63)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (16)
#endif

/* _ns1__userType_attributesMap_entry has binding name '_ns1__userType_attributesMap_entry' for type '' */
#ifndef SOAP_TYPE__ns1__userType_attributesMap_entry
#define SOAP_TYPE__ns1__userType_attributesMap_entry (87)
#endif

/* _ns1__userType_attributesMap has binding name '_ns1__userType_attributesMap' for type '' */
#ifndef SOAP_TYPE__ns1__userType_attributesMap
#define SOAP_TYPE__ns1__userType_attributesMap (86)
#endif

/* ns1__variableStoreType_ has binding name 'ns1__variableStoreType_' for type 'ns1:variableStoreType' */
#ifndef SOAP_TYPE_ns1__variableStoreType_
#define SOAP_TYPE_ns1__variableStoreType_ (66)
#endif

/* ns1__classPresentationType_ has binding name 'ns1__classPresentationType_' for type 'ns1:classPresentationType' */
#ifndef SOAP_TYPE_ns1__classPresentationType_
#define SOAP_TYPE_ns1__classPresentationType_ (64)
#endif

/* ns1__reassignTasksResponse has binding name 'ns1__reassignTasksResponse' for type 'ns1:reassignTasksResponse' */
#ifndef SOAP_TYPE_ns1__reassignTasksResponse
#define SOAP_TYPE_ns1__reassignTasksResponse (62)
#endif

/* ns1__reassignTasks has binding name 'ns1__reassignTasks' for type 'ns1:reassignTasks' */
#ifndef SOAP_TYPE_ns1__reassignTasks
#define SOAP_TYPE_ns1__reassignTasks (61)
#endif

/* ns1__getTaskResponse has binding name 'ns1__getTaskResponse' for type 'ns1:getTaskResponse' */
#ifndef SOAP_TYPE_ns1__getTaskResponse
#define SOAP_TYPE_ns1__getTaskResponse (60)
#endif

/* ns1__getTask has binding name 'ns1__getTask' for type 'ns1:getTask' */
#ifndef SOAP_TYPE_ns1__getTask
#define SOAP_TYPE_ns1__getTask (59)
#endif

/* ns1__getProcessTasksResponse has binding name 'ns1__getProcessTasksResponse' for type 'ns1:getProcessTasksResponse' */
#ifndef SOAP_TYPE_ns1__getProcessTasksResponse
#define SOAP_TYPE_ns1__getProcessTasksResponse (58)
#endif

/* ns1__getProcessTasks has binding name 'ns1__getProcessTasks' for type 'ns1:getProcessTasks' */
#ifndef SOAP_TYPE_ns1__getProcessTasks
#define SOAP_TYPE_ns1__getProcessTasks (57)
#endif

/* ns1__completeTaskWSResponse has binding name 'ns1__completeTaskWSResponse' for type 'ns1:completeTaskWSResponse' */
#ifndef SOAP_TYPE_ns1__completeTaskWSResponse
#define SOAP_TYPE_ns1__completeTaskWSResponse (56)
#endif

/* ns1__variable has binding name 'ns1__variable' for type 'ns1:variable' */
#ifndef SOAP_TYPE_ns1__variable
#define SOAP_TYPE_ns1__variable (55)
#endif

/* ns1__completeTaskWS has binding name 'ns1__completeTaskWS' for type 'ns1:completeTaskWS' */
#ifndef SOAP_TYPE_ns1__completeTaskWS
#define SOAP_TYPE_ns1__completeTaskWS (54)
#endif

/* ns1__getTasksResponse has binding name 'ns1__getTasksResponse' for type 'ns1:getTasksResponse' */
#ifndef SOAP_TYPE_ns1__getTasksResponse
#define SOAP_TYPE_ns1__getTasksResponse (53)
#endif

/* ns1__getTasks has binding name 'ns1__getTasks' for type 'ns1:getTasks' */
#ifndef SOAP_TYPE_ns1__getTasks
#define SOAP_TYPE_ns1__getTasks (52)
#endif

/* ns1__assignTaskResponse has binding name 'ns1__assignTaskResponse' for type 'ns1:assignTaskResponse' */
#ifndef SOAP_TYPE_ns1__assignTaskResponse
#define SOAP_TYPE_ns1__assignTaskResponse (51)
#endif

/* ns1__assignTask has binding name 'ns1__assignTask' for type 'ns1:assignTask' */
#ifndef SOAP_TYPE_ns1__assignTask
#define SOAP_TYPE_ns1__assignTask (50)
#endif

/* ns1__markTaskOpenedResponse has binding name 'ns1__markTaskOpenedResponse' for type 'ns1:markTaskOpenedResponse' */
#ifndef SOAP_TYPE_ns1__markTaskOpenedResponse
#define SOAP_TYPE_ns1__markTaskOpenedResponse (49)
#endif

/* ns1__markTaskOpened has binding name 'ns1__markTaskOpened' for type 'ns1:markTaskOpened' */
#ifndef SOAP_TYPE_ns1__markTaskOpened
#define SOAP_TYPE_ns1__markTaskOpened (48)
#endif

/* ns1__userType has binding name 'ns1__userType' for type 'ns1:userType' */
#ifndef SOAP_TYPE_ns1__userType
#define SOAP_TYPE_ns1__userType (47)
#endif

/* ns1__variableDefinition has binding name 'ns1__variableDefinition' for type 'ns1:variableDefinition' */
#ifndef SOAP_TYPE_ns1__variableDefinition
#define SOAP_TYPE_ns1__variableDefinition (46)
#endif

/* ns1__wfVariable has binding name 'ns1__wfVariable' for type 'ns1:wfVariable' */
#ifndef SOAP_TYPE_ns1__wfVariable
#define SOAP_TYPE_ns1__wfVariable (45)
#endif

/* ns1__wfTask has binding name 'ns1__wfTask' for type 'ns1:wfTask' */
#ifndef SOAP_TYPE_ns1__wfTask
#define SOAP_TYPE_ns1__wfTask (44)
#endif

/* ns1__getMyTasksResponse has binding name 'ns1__getMyTasksResponse' for type 'ns1:getMyTasksResponse' */
#ifndef SOAP_TYPE_ns1__getMyTasksResponse
#define SOAP_TYPE_ns1__getMyTasksResponse (43)
#endif

/* ns1__batchPresentation has binding name 'ns1__batchPresentation' for type 'ns1:batchPresentation' */
#ifndef SOAP_TYPE_ns1__batchPresentation
#define SOAP_TYPE_ns1__batchPresentation (42)
#endif

/* ns1__getMyTasks has binding name 'ns1__getMyTasks' for type 'ns1:getMyTasks' */
#ifndef SOAP_TYPE_ns1__getMyTasks
#define SOAP_TYPE_ns1__getMyTasks (41)
#endif

/* ns1__reassignTaskResponse has binding name 'ns1__reassignTaskResponse' for type 'ns1:reassignTaskResponse' */
#ifndef SOAP_TYPE_ns1__reassignTaskResponse
#define SOAP_TYPE_ns1__reassignTaskResponse (40)
#endif

/* ns1__reassignTask has binding name 'ns1__reassignTask' for type 'ns1:reassignTask' */
#ifndef SOAP_TYPE_ns1__reassignTask
#define SOAP_TYPE_ns1__reassignTask (39)
#endif

/* ns1__authenticateByKerberosResponse has binding name 'ns1__authenticateByKerberosResponse' for type 'ns1:authenticateByKerberosResponse' */
#ifndef SOAP_TYPE_ns1__authenticateByKerberosResponse
#define SOAP_TYPE_ns1__authenticateByKerberosResponse (38)
#endif

/* ns1__authenticateByKerberos has binding name 'ns1__authenticateByKerberos' for type 'ns1:authenticateByKerberos' */
#ifndef SOAP_TYPE_ns1__authenticateByKerberos
#define SOAP_TYPE_ns1__authenticateByKerberos (37)
#endif

/* ns1__authenticateByTrustedPrincipalResponse has binding name 'ns1__authenticateByTrustedPrincipalResponse' for type 'ns1:authenticateByTrustedPrincipalResponse' */
#ifndef SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse
#define SOAP_TYPE_ns1__authenticateByTrustedPrincipalResponse (36)
#endif

/* ns1__authenticateByTrustedPrincipal has binding name 'ns1__authenticateByTrustedPrincipal' for type 'ns1:authenticateByTrustedPrincipal' */
#ifndef SOAP_TYPE_ns1__authenticateByTrustedPrincipal
#define SOAP_TYPE_ns1__authenticateByTrustedPrincipal (35)
#endif

/* ns1__authenticateByLoginPasswordResponse has binding name 'ns1__authenticateByLoginPasswordResponse' for type 'ns1:authenticateByLoginPasswordResponse' */
#ifndef SOAP_TYPE_ns1__authenticateByLoginPasswordResponse
#define SOAP_TYPE_ns1__authenticateByLoginPasswordResponse (34)
#endif

/* ns1__authenticateByLoginPassword has binding name 'ns1__authenticateByLoginPassword' for type 'ns1:authenticateByLoginPassword' */
#ifndef SOAP_TYPE_ns1__authenticateByLoginPassword
#define SOAP_TYPE_ns1__authenticateByLoginPassword (33)
#endif

/* ns1__wfExecutor has binding name 'ns1__wfExecutor' for type 'ns1:wfExecutor' */
#ifndef SOAP_TYPE_ns1__wfExecutor
#define SOAP_TYPE_ns1__wfExecutor (32)
#endif

/* ns1__identifiable has binding name 'ns1__identifiable' for type 'ns1:identifiable' */
#ifndef SOAP_TYPE_ns1__identifiable
#define SOAP_TYPE_ns1__identifiable (31)
#endif

/* ns1__identifiableBase has binding name 'ns1__identifiableBase' for type 'ns1:identifiableBase' */
#ifndef SOAP_TYPE_ns1__identifiableBase
#define SOAP_TYPE_ns1__identifiableBase (30)
#endif

/* ns1__executor has binding name 'ns1__executor' for type 'ns1:executor' */
#ifndef SOAP_TYPE_ns1__executor
#define SOAP_TYPE_ns1__executor (29)
#endif

/* ns1__actor has binding name 'ns1__actor' for type 'ns1:actor' */
#ifndef SOAP_TYPE_ns1__actor
#define SOAP_TYPE_ns1__actor (28)
#endif

/* ns1__user has binding name 'ns1__user' for type 'ns1:user' */
#ifndef SOAP_TYPE_ns1__user
#define SOAP_TYPE_ns1__user (27)
#endif

/* ns1__authenticateByCallerPrincipalResponse has binding name 'ns1__authenticateByCallerPrincipalResponse' for type 'ns1:authenticateByCallerPrincipalResponse' */
#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse
#define SOAP_TYPE_ns1__authenticateByCallerPrincipalResponse (26)
#endif

/* ns1__authenticateByCallerPrincipal has binding name 'ns1__authenticateByCallerPrincipal' for type 'ns1:authenticateByCallerPrincipal' */
#ifndef SOAP_TYPE_ns1__authenticateByCallerPrincipal
#define SOAP_TYPE_ns1__authenticateByCallerPrincipal (25)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (22)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (20)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (19)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (17)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (15)
#endif

/* xsd__base64Binary_ has binding name 'xsd__base64Binary_' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (14)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (10)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (153)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (152)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (149)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (147)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (146)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (155)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (154)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (148)
#endif

/* ns1__reassignTasks * has binding name 'PointerTons1__reassignTasks' for type 'ns1:reassignTasks' */
#ifndef SOAP_TYPE_PointerTons1__reassignTasks
#define SOAP_TYPE_PointerTons1__reassignTasks (142)
#endif

/* ns1__getTask * has binding name 'PointerTons1__getTask' for type 'ns1:getTask' */
#ifndef SOAP_TYPE_PointerTons1__getTask
#define SOAP_TYPE_PointerTons1__getTask (138)
#endif

/* ns1__getProcessTasks * has binding name 'PointerTons1__getProcessTasks' for type 'ns1:getProcessTasks' */
#ifndef SOAP_TYPE_PointerTons1__getProcessTasks
#define SOAP_TYPE_PointerTons1__getProcessTasks (134)
#endif

/* ns1__completeTaskWS * has binding name 'PointerTons1__completeTaskWS' for type 'ns1:completeTaskWS' */
#ifndef SOAP_TYPE_PointerTons1__completeTaskWS
#define SOAP_TYPE_PointerTons1__completeTaskWS (129)
#endif

/* ns1__getTasks * has binding name 'PointerTons1__getTasks' for type 'ns1:getTasks' */
#ifndef SOAP_TYPE_PointerTons1__getTasks
#define SOAP_TYPE_PointerTons1__getTasks (125)
#endif

/* ns1__assignTask * has binding name 'PointerTons1__assignTask' for type 'ns1:assignTask' */
#ifndef SOAP_TYPE_PointerTons1__assignTask
#define SOAP_TYPE_PointerTons1__assignTask (120)
#endif

/* ns1__markTaskOpened * has binding name 'PointerTons1__markTaskOpened' for type 'ns1:markTaskOpened' */
#ifndef SOAP_TYPE_PointerTons1__markTaskOpened
#define SOAP_TYPE_PointerTons1__markTaskOpened (115)
#endif

/* ns1__getMyTasks * has binding name 'PointerTons1__getMyTasks' for type 'ns1:getMyTasks' */
#ifndef SOAP_TYPE_PointerTons1__getMyTasks
#define SOAP_TYPE_PointerTons1__getMyTasks (111)
#endif

/* ns1__reassignTask * has binding name 'PointerTons1__reassignTask' for type 'ns1:reassignTask' */
#ifndef SOAP_TYPE_PointerTons1__reassignTask
#define SOAP_TYPE_PointerTons1__reassignTask (107)
#endif

/* ns1__authenticateByKerberos * has binding name 'PointerTons1__authenticateByKerberos' for type 'ns1:authenticateByKerberos' */
#ifndef SOAP_TYPE_PointerTons1__authenticateByKerberos
#define SOAP_TYPE_PointerTons1__authenticateByKerberos (103)
#endif

/* ns1__authenticateByTrustedPrincipal * has binding name 'PointerTons1__authenticateByTrustedPrincipal' for type 'ns1:authenticateByTrustedPrincipal' */
#ifndef SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipal
#define SOAP_TYPE_PointerTons1__authenticateByTrustedPrincipal (99)
#endif

/* ns1__authenticateByLoginPassword * has binding name 'PointerTons1__authenticateByLoginPassword' for type 'ns1:authenticateByLoginPassword' */
#ifndef SOAP_TYPE_PointerTons1__authenticateByLoginPassword
#define SOAP_TYPE_PointerTons1__authenticateByLoginPassword (95)
#endif

/* ns1__authenticateByCallerPrincipal * has binding name 'PointerTons1__authenticateByCallerPrincipal' for type 'ns1:authenticateByCallerPrincipal' */
#ifndef SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal
#define SOAP_TYPE_PointerTons1__authenticateByCallerPrincipal (91)
#endif

/* ns1__variable * has binding name 'PointerTons1__variable' for type 'ns1:variable' */
#ifndef SOAP_TYPE_PointerTons1__variable
#define SOAP_TYPE_PointerTons1__variable (89)
#endif

/* enum ns1__variableStoreType * has binding name 'PointerTons1__variableStoreType' for type 'ns1:variableStoreType' */
#ifndef SOAP_TYPE_PointerTons1__variableStoreType
#define SOAP_TYPE_PointerTons1__variableStoreType (84)
#endif

/* ns1__userType * has binding name 'PointerTons1__userType' for type 'ns1:userType' */
#ifndef SOAP_TYPE_PointerTons1__userType
#define SOAP_TYPE_PointerTons1__userType (82)
#endif

/* xsd__anyType * has binding name 'PointerToxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_PointerToxsd__anyType
#define SOAP_TYPE_PointerToxsd__anyType (81)
#endif

/* ns1__variableDefinition * has binding name 'PointerTons1__variableDefinition' for type 'ns1:variableDefinition' */
#ifndef SOAP_TYPE_PointerTons1__variableDefinition
#define SOAP_TYPE_PointerTons1__variableDefinition (80)
#endif

/* ns1__wfVariable * has binding name 'PointerTons1__wfVariable' for type 'ns1:wfVariable' */
#ifndef SOAP_TYPE_PointerTons1__wfVariable
#define SOAP_TYPE_PointerTons1__wfVariable (78)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (77)
#endif

/* ns1__wfExecutor * has binding name 'PointerTons1__wfExecutor' for type 'ns1:wfExecutor' */
#ifndef SOAP_TYPE_PointerTons1__wfExecutor
#define SOAP_TYPE_PointerTons1__wfExecutor (76)
#endif

/* ns1__wfTask * has binding name 'PointerTons1__wfTask' for type 'ns1:wfTask' */
#ifndef SOAP_TYPE_PointerTons1__wfTask
#define SOAP_TYPE_PointerTons1__wfTask (74)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (73)
#endif

/* enum ns1__classPresentationType * has binding name 'PointerTons1__classPresentationType' for type 'ns1:classPresentationType' */
#ifndef SOAP_TYPE_PointerTons1__classPresentationType
#define SOAP_TYPE_PointerTons1__classPresentationType (72)
#endif

/* ns1__batchPresentation * has binding name 'PointerTons1__batchPresentation' for type 'ns1:batchPresentation' */
#ifndef SOAP_TYPE_PointerTons1__batchPresentation
#define SOAP_TYPE_PointerTons1__batchPresentation (71)
#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_PointerToLONG64
#define SOAP_TYPE_PointerToLONG64 (70)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (69)
#endif

/* ns1__actor * has binding name 'PointerTons1__actor' for type 'ns1:actor' */
#ifndef SOAP_TYPE_PointerTons1__actor
#define SOAP_TYPE_PointerTons1__actor (68)
#endif

/* ns1__user * has binding name 'PointerTons1__user' for type 'ns1:user' */
#ifndef SOAP_TYPE_PointerTons1__user
#define SOAP_TYPE_PointerTons1__user (67)
#endif

/* wchar_t * has binding name 'wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_wstring
#define SOAP_TYPE_wstring (24)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (13)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__variable *>  has binding name 'std__vectorTemplateOfPointerTons1__variable' for type 'ns1:variable' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__variable
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__variable (90)
#endif

/* std::vector<_ns1__userType_attributesMap_entry>  has binding name 'std__vectorTemplateOf_ns1__userType_attributesMap_entry' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_ns1__userType_attributesMap_entry
#define SOAP_TYPE_std__vectorTemplateOf_ns1__userType_attributesMap_entry (88)
#endif

/* std::vector<ns1__variableDefinition *>  has binding name 'std__vectorTemplateOfPointerTons1__variableDefinition' for type 'ns1:variableDefinition' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__variableDefinition
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__variableDefinition (85)
#endif

/* std::vector<ns1__userType *>  has binding name 'std__vectorTemplateOfPointerTons1__userType' for type 'ns1:userType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__userType
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__userType (83)
#endif

/* std::vector<ns1__wfVariable *>  has binding name 'std__vectorTemplateOfPointerTons1__wfVariable' for type 'ns1:wfVariable' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__wfVariable
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__wfVariable (79)
#endif

/* std::vector<ns1__wfTask *>  has binding name 'std__vectorTemplateOfPointerTons1__wfTask' for type 'ns1:wfTask' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__wfTask
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__wfTask (75)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
